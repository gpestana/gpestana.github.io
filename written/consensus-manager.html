<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
      
    <title>gpestana</title>
    
    <link href="../assets/bootstrap.css" rel="stylesheet">
    <link href="../assets/mine.css" rel="stylesheet">

 </head>

  <body>

<div id = "wrapper">

<div class = "written-menu">
  <ul>
    <li><a href="../index.html">home</a></li>
    <li><a href="./index.html">written</a></li>
    <li><a href="../index.html">contacts</a></li>
  </ul>
</div>

<div id = "article">
<div class="row">
<div class = "col-md-7">
<h3>Consensus Manager module for Node.js</h3>

<h5>October 2014</h5>

<br>
<p>
In one of my side-project - which uses socket.io - I need to
reach a consensus amongst users in the same room. Initial
requirements:
<ul>
<li> The definition of 'consensus' should be flexible and interchangeable in
run-time;</li>
<li> The time to reach the consensus should be tracked;</li>
<li> The final consensus amongst the clients could possibly output some data
that the server may need to use further on;</li>
</ul>
</p>
<p>
<br>
My solution consists of a modular entity which I pompously called <i> consensus
manager</i>. It is responsible for starting the consensus process and receiving 
and processing the responses from the
clients. Finally, according to a pre-defined strategy, it puts an end to the protocol when the
consensus has been reached. In addition, the consensus manager keeps track of the time taken for the whole process to be concluded, as well as stores the data coming from the clients.
</p>

<p>
The module is available on npm:
</p>
<pre>
$ npm install consensus-manager
</pre>

<br>

<p>
As an example, let's consider a simple case: In a chat system, there are <i>X</i> peers
connected to a server at a given time. The server should fire an event when half
of the peers had communicated how many lines of chat each of them wrote, which
is stored locally. Let's also consider that the connection is
 maintained with socket.io.
</p>
<p>
First, we must implement the consensus strategy, or the logic that defines what a
<i>consensus</i> is:
</p>


<pre id="code">
module.exports = strategy_half

function strategy_half(min_res) {
  this.min_res    = min_res //where min_res is half of the X room users
}

strategy_half.prototype.isReady = function(results, time_diff, cb) {
  if(results.length == this.min_res) {
    cb(true, results, time_diff)
  }
  else cb(false)
}
</pre>
<p>
The strategy is then passed in the consensus manager constructor:
</p>

<pre id="code">
var ConsensusManager = require('consensus-manager'),
Strategy             = require('... strategy_half.js')

var strategy = new Strategy(min_res)
var consensus = new ConsensusManager(strategy)
</pre>

<p>
The underlying layers should take care of the communication between server and peers.
Considering a socket.io communication layer, it would be something like this:
</p>

<pre id="code">
socket.in(roomID).emit('askNumberLines')


socket.on('numberLinesResponse', function(nr_lines) {
  consensus.process(nr_lines)
})
</pre>

<p>
Finally, when the requirements implemented by the strategy are met, a
<i>consensus</i> event is triggered:
</p>

<pre id="code">
consensus.on('consensus', function(output, time_diff) {
 //half of the peers answered and: 
 //i) ouput contains their responses, 
 //ii) time_diff says how much time did the process take.
})
</pre>

<p>
If the responses keep coming from peers after the protocol is over, the manager
will trigger a <i>notListening</i> event.
</p>

<br>
<p>
This solution is modular and extensible enough to structure and abstract
simple scenarios of consensus and synchronization between peers, both in remote
and local domains. The decoupling between the consensus manager and the definition
of consensus itself is what does the magic here.
</p>

<br><br>

Discussion: <a href="https://news.ycombinator.com/item?id=8448693">https://news.ycombinator.com/item?id=8448693</a><br>
Code: <a href="https://github.com/gpestana/consensus-manager">https://github.com/gpestana/consensus-manager</a><br>



</div>
</div>

<div id="footer"></div>

</div> <!-- wrapper-->

</body>
</html>

